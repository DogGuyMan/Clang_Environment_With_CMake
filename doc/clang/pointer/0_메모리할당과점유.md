## 1. 메모리 할당과 점유

---

> ### 📄 1. 할당 (Allocation)

#### 운영체제가 메모리에 특정 크기의 메모리 블록을 예약하는 과정

```c
int val; // 0x1000~0x1003 까지 메모리 공간을 차지할때,
```

1. 변수 x를 위해 0x1000~0x1003 까지 메모리 공간이 예약되어 있는 상태다.
2. 이렇게 예약이 되었다면 다른 프로세스가 사용할 수 없는것을 보장한다.
3. 이 시점에서는 실제 데이터는 없는 쓰레기 값이 들어가 있다.

---

> ### 📄 2. 점유 (Occupation)

#### CPU가 예약된 메모리 블럭에 실제로 데이터를 저장되는 과정.

```c
val = 10; // 0x0000000A (10의 이진 표현)이란 의미있는 데이터를 기록
```

1. CPU 레지스터에서 시작해서
캐시 계층(L1, L2, L3) 구조를 거쳐 (Cache Write Hit 정책)에 따라.
실제 물리 메모리까지 데이터를 전송
2. 데이터 전송을 마쳤다면 예약된 메모리 블럭에 0x0000000A (10의 이진 표현)이란 의미있는 데이터를 기록한다.
3. 이렇게 점유된 상태라는 것인 자원이 사용중** 이라는 다른 표현으로도 부르기도 하고, 자원을 해제되지 않는다.

---

> ### 📄 3. 시스템 관점에서의 차이점

| 구분 | 할당 (Allocation) | 점유 (Occupation) |
|---|---|---|
| 주체 | 메모리 관리자 (OS/컴파일러) | CPU/프로그램 |
| 작업 | 변수 선언 시 주소 공간 예약 | 값 대입 시, 실제 데이터 저장 |

---

> ### 📄 4. 정적할당과 동적 할당

#### 1). 정적 할당

* **타이밍?**
  * **할당** : 컴파일 타임, 프로세스 시작 직전에 메모리 블럭을 고정적으로 예약하거나, 미리 계산을 한다.
  * **해제** :
    * `static`, `global` 변수라면 프로세스가 종료될 때까지 상시 점유된다. 정적할당된 메모리 공간은 다른 프로세스에 의해 사용될 일이 절대로 없다.
    * 하지만, 함수 내부에서 유요한 `local` `parameter` 같은 경우라면 stack에서 빠져나갈때, 해제된다.
* **어디에?**
  * 함수내 지역,매개변수면 **Stack** 메모리 블럭을 예약하는 것
  * 전역, 정적(`static`) 변수면 **Data** 메모리 블럭을 예약하는 것
* 따라서 프로세스 실행중에 해제가 불가능하다 했지?
  혹은 함수내 지역 변수면 모를까.. 스코프 최상단의 전역 변수에 아주 큰 값을 할당하면, 불필요한 메모리를 초과하거나 낭비할 수 있다.

#### 2). 동적 할당

* **타이밍?**
  * **할당** : 런타임에 프로세스가 돌아가는 중에 메모리 블럭을 예약하는 것 이다. `malloc` `new`
    *정적 할당 타이밍에 수행하지 못하였기 때문에*
  * **해제** : 프로세스가 종료될 때 모든 자원을 회수하기도 하지만,
  런타임 중에 할당되는것이 가능했기 떄문에 그 반대도 마찬가지로 **런타임 중에 필요 없을때, 명시적으로 해제 되야한다** `free` `delete`
  그렇게 된다면 다른 프로세스가 이를 재활용 할 수 있다.
* **어디에?** : **Heap** 메모리에 값을 예약하는 것
* 따라서, 프로세스 실행중에 할당 해제가 가능하고, 할당 크기도 크지만, 잘못 관리하면 memory leak이 발생한다.

---

> ### 📄 5. `malloc & free` VS `new & delete`

#### 1). `new` & `delete`

* `new` : 메모리 할당 + 생성자
  * 딱, 지정된 타입 크기만큼 한번 메모리를 할당하기 때문에.
  컨테이너, 배열같은 경우 for문을 사용해 연달아 할당할 필요가 있다.
* `delete` : 메모리 해제 + 소멸자
  * 마찬가지로 for문을 통해 연달아 해제를 할 필요가 있다.

* 특징
    * 이렇게 되면 메모리 할당 해제 뿐만 아니라, 초기화(점유)까지 자동화 해준다.
    * 그렇다면 malloc과 free는 위 일부를 수행하지 않는다고 보면 되나? *예*

#### 2). `malloc` & `free`

* `malloc` : 메모리 할당
  * `malloc`이 반환하는 타입은 `(void *)`와 같은
  제네릭 포인터를 내보낸다 따라서 형변환이 필수다.
  * 하지만, 메모리 할당 크기를 자연수 크기로 정해줄 수 있다.
* `free` : 메모리 해제
  * 만약 오브젝트간 복잡한 의존 관계로 얽혀 있으며,
  해제시 연달아 재귀적으로 해제해야 하는 로직에 대응하기 매우 어렵다.

#### 3). 표

| **특징**     | **`malloc` / `free`** | **`new` / `delete`**               |
|---|---|---|
| **언어**     | C, C++                | C++                                |
| **객체 초기화** | 없음                    | 생성자 호출로 객체 초기화 가능                  |
| **타입 안전성** | 없음 (형변환 필요)           | 타입 안전 (형변환 필요 없음)                  |
| **메모리 해제** | `free` 호출             | `delete` 또는 `delete[]` 호출          |
| **예외 처리**  | 메모리 할당 실패 시 `NULL` 반환   | 메모리 할당 실패 시 `std::bad_alloc` 예외 발생 |


---

> #### 참고

* [warfd : c/c++ 정리(27) 포인터](https://blog.naver.com/warfd/223899246058)
* [eludien : 메모리 영역, 동적 할당, 정적 할당 / Code, Data, Heap, Stack / malloc, free, new, delete](https://blog.naver.com/eludien/221462352935)
* https://www.youtube.com/watch?v=vjYF_fAZI5E&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&index=25&ab_channel=ChrisTerman
* https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory
