> ### 📄 2. 포인터와 주소값

---

#### 1). [할당된 메모리에 값 점유](./0_메모리할당과점유.md#2-점유-occupation)

* 여기서도 알다싶이.
값이란 데이터가 할당된 메모리에 저장되야지..
그제서야 **사용중**이라고 부를 수 있는것이다.
* 이때, 원시타입 값은 `int, float, double, char`... 등등.

---

#### 2). 값 VS 주소 값

#### 호출한 함수에 변수를 전달할 때, 두가지로 분류 할 수 있다.

##### ① "점유 값 복사", "값에 의한 호출"

* `int arg1`, `int arg2` 각각은 "복사된 값"을 받는다

##### ② "할당 주소 값 복사", "참조에 의한 호출"
* **예약된 메모리 블럭을 자체를 나타내는 값도 있을까?** 라는 것이고, 그러한 값이 바로 **주소값**이라 불리는 것이다.
* `int* arg1`, `int* arg2` 각각은 **"주소값의 복사본"을 받는다**
* 주의할 점은 포인터 자체도 값에 의한 호출이다. 다만 그 값이 **주소값**일 뿐이다.

---


#### 4). 포인터 타입

#### 포인터 타입을 할당하는 크기는 CPU 아키텍쳐(32bit, 64bit)에 따라 다르다.

##### ① `void *` 타입

* 가장 기본적이고 제네릭한 **주소값을 저장하는 타입(type)**은
`(void *)` 라는 형태이고 **제네릭 포인터**라고 한다.
* 이것은 어떤 자료형의 주소값도 저장할 수 있다.
* 실제 데이터 타입 정보를 포함하지 않기 때문에 이 주소가 가리키는 데이터가 어떤 형식인지는 **별도의 처리 없이는 알 수 없다.**
  * 그 **할당된 메모리를 어떤 타입으로 해석해야 할지 명시하는 처리가 필요**하다.
  * 그 처리란 **역참조 전에 적절한 포인터 타입으로 명시적 캐스팅**을 말한다.

##### ② 타입 호환성
* `int`(4byte), `float`(4byte)의 크기가 같다고 해서
* `float*` 포인터에 저장된 주소값을 `int*` 포인터에 캐스팅하여 대입할 수는 있지만, 역참조 시에 올바른 값에 접근할 수 있는지는 보장할 수 없다.
* **같은 메모리 위치라도 해석 방식이 다르기 때문**이다.
  ```c
  /* ./compatibilityTest */
  #include "stdio.h"

  int main() {
    float f = 12.34;
    float* fp = &f;
    int* ip = (int*)&f;
    printf("%p : %f\n", fp, *fp);
    printf("%p : %d\n", ip, *ip);
  }
  ```

  ```bash
  > ./compatibilityTest
  0x16fbaa32c : 12.340000
  0x16fbaa32c : 1095069860
  ```

---

#### 5). `&` VS `*`

##### ① 1. 주소(참조) 연산자 `&`

* 값 -> 주소
* 변수의 값이 아니라, **값이 저장된 메모리의 주소**를 얻을 때
* `int * 포인터변수`에 주소를 저장할 때 사용.
    ```c
    int x = 10;
    int *p = &x;  // x의 주소를 p에 저장
    ```

##### ② 2. 역참조 연산자 `*`

* 주소 -> 값
* 반대로 포인터가 가르키는 주소를 통해 역으로 **값을 참조**하는 것.
* 메모리 주소에 저장된 값을 참조하거나 변경할 때 사용.
    ```c
    int x = 10;
    int *p = &x;  // x의 주소를 p에 저장
    int y = *p;   // p가 가리키는 값을 y에 저장 int y = x와 동일
    ```
* 포인터 변수를 매개변수로 가져올 때 (ref, out)으로 쓸때,
    ```c
    void convertM2HM(int min, int *h, int *m) {
        *h = min / 60;
        *m = min % 60;
    }
    void swap(int *l, int *r) {
        int tmp = *l;
        *l = *r;
        *r = tmp;
    }
    int main() {
        int M, hours, minutes;
        convertM2HM(M, &hours, &minutes);

        int a = 30, b = 77;
        swap(&a, &b);
    }
    ```

---

#### 6). 포인터를 사용하는 이유와 주의할 점

##### ① 포인터를 사용하는 사례로 바라 봤을떄,

1. **배열과 문자열 처리**: 데이터의 거대한 나열이 필요할 때, 나열의 첫 시작을 가르키도록
   * **고정 크기 버퍼 선언하기**
2. **성능 최적화**: 거대한 데이터가 복사가 일어나지 않기 위해, *꿀돼지가 음직이는것 보단 가벼운 내가 직접 보러가는게 좋다는..*
   * 이미지 처리나 3D 그래픽 연산에서 빠른 픽셀 조작이 가능해집니다.
3. **자료구조 구현**: 연결 리스트, 트리, 그래프의 노드 연결
4. **하드웨어 접근**: 특정 메모리 주소의 하드웨어 레지스터 직접 제어
   * **동적으로 메모리 자원 조작**
   * **함수 포인터**: 실행할 함수를 동적으로 결정 (콜백, 다형성)

##### ② 포인터 사용시 주의해야 할 점들

1. **메모리 누수 (Memory Leak)**: `malloc` 후 `free` 누락
2. **댕글링 포인터 (Dangling Pointer)**: 해제된 메모리를 가리키는 포인터 사용
3. **널 포인터 역참조**: 초기화되지 않거나 NULL인 포인터 역참조
4. **버퍼 오버플로우**: 할당된 메모리 범위를 벗어난 접근
5. **이중 해제 (Double Free)**: 같은 메모리를 두 번 해제
6. **와일드 포인터**: 임의의 값으로 초기화된 포인터 사용

---

https://rito15.github.io/posts/cs-unsafe-and-fixed/
https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/unsafe-code
https://stackoverflow.com/questions/30064801/understanding-unsafe-code-and-its-uses
https://www.geeksforgeeks.org/c-sharp/unsafe-code-in-c-sharp/
https://m.cafe.daum.net/csharp-novice/5ijJ/41
https://m.blog.naver.com/techshare/223540085591
https://www.sysnet.pe.kr/2/0/13709?pageno=1
