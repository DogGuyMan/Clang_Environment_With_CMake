## 공간 지역성


> ### 📄 1장. 데이터 지역성

* **정의**: 캐시 메모리 성능을 최적화하는데 유용한 개념

#### 시간 지역성

* **원리**: 캐시에 한 메모리 구간을 적재할 때, 반복적으로 접근할 것을 함께 적재
* **장점**: 최근에 접근한 데이터가 다시 접근할 확률이 높다는 것을 의미한다.
예를 들어 반복문에서 같은 변수에 여러번 접근하는 것이다.

#### 공간 지역성

* **원리**: 캐시에 한 메모리 구간을 적재할 때, 인접한 영역을 함께 적재
* **장점**: 메모리 간 서로 인접한 영역에 접근할 때 성능 향상

##### 공간 지역성이 좋다는것은 뭐지?
* 공간 지역성이 좋은 경우: 배열
    * 시작 포인터 기반 접근
    * 자료형 크기만큼 사칙 연산으로 다음 원소 접근
    * 연속적인 메모리 배치로 캐시 효율성 극대화

##### 공간 지역성이 좋지 않다는것
* 링크드 리스트 같은 경우에 공간 지역성이.. 아주 나쁘다.
    * 지역성 재활용 불가능
    * 메모리가 비연속적으로 분산되어 캐시 미스 빈발

### 참고

* https://crewdaniel.github.io/posts/cs_1/

---

> ### 📄 2장. 성능 분석: 배열 vs 연결 리스트

#### 2.1 Big O 표기법의 한계
* **사실**: 암호화된 텍스트 무차별 대입 공격은 O(1)이지만 상수가 매우 큼
* **실제**: 이론적 복잡도와 실제 성능의 차이
- 배열 스트리밍이 작은 크기에서 HashSet보다 빠른 경우 발생

#### 2.2 정렬된 삽입 연산 비교

##### 연결 리스트 (이중 연결)
* **삽입 단계**: 정확히 4개 포인터 리디렉션 (A→next, B→next, B→prev, C→prev)
* **선형 스캔**: 1~N번 비교 (평균 N/2)
* **방문 횟수**: 평균 N/2번, 최악 N번

##### 벡터 (배열)
* **스왑 연산**: 0~N번 (정확히 N - 비교 횟수)
* **용량 부족 시**: 추가로 N번 스왑 (재할당)
* **방문 횟수**: 항상 N번 (스캔 + 삽입)

---

> ### 📄 3장. 실제 성능 측정과 캐시 영향

#### 3.1 L3 캐시 성능 지표
* **지연 시간**: 40ns
* **대역폭**: 400GB/s 이상
* **32비트 정수**: 약 100개/ns (0.01ns/int)

#### 3.2 실제 성능 비교

##### 연결 리스트
* **각 노드 방문**: 평균 최소 20ns (간접 참조로 인한 캐시 지연)
* **총 삽입 시간**: 40~20N ns
* **50,000개 요소**: 40ns~1ms/삽입

##### 벡터
* **초기 캐시 지연**: 한 번만 발생 (40ns)
* **총 삽입 시간**: 약 (40 + 0.01N)ns
* **50,000개 요소**: 500ns (0.0005ms)/삽입

#### 3.3 성능 차이의 원인
* **예측 가능한 접근 패턴**
* **캐시 친화적 코드**
* **포인터 리디렉션 횟수 최소화**
* **연속적 메모리 접근**

---

> ### 📄 4장. 메모리 관리와 시스템 영향

#### 4.1 힙 단편화 문제
- 연결 리스트와 포인터 구조체가 힙 단편화 야기
- 시스템의 메모리 압축 필요성 증가
- 대부분 프로그래머가 간과하는 성능 영향

#### 4.2 캐시 친화적 프로그래밍의 중요성
- 과거: 캐시 친화적 코드 드물었음
- 현재: 새로운 캐시 기술로 배열의 필요성 증대
* **주의사항**: 성능 측정 없는 최적화는 무의미

---

> ### 📄 5장. 연결 리스트의 적절한 사용 사례

#### 5.1 연결 리스트가 유용한 경우
* **커서 기반 접근**: 검색 없이 직접 참조 가능
* **데이터 타입 내장**: appendAfter() 등 효율적 함수 호출
* **특정 목적**: 이전/다음 포인터가 요소 자체에 있는 경우

#### 5.2 연결 리스트 사용 시 주의사항
* **커서의 중요성**: 커서 없는 연결 리스트 ≈ 암호화된 인덱스를 가진 벡터
* **검색 비용**: 노드 검색이 필요한 경우 비용 고려
* **컨테이너 부적합**: 선형 검색 문제로 범용 컨테이너로 부적절

---

> ### 📄 6장. 하이브리드 접근법

#### 6.1 청크 기반 연결 리스트
* **구조**: 최대 4K 요소의 청크를 연결 리스트로 연결
* **장점**: 연결 리스트의 유연성 + 배열의 성능
* **동적 관리**:
  - 4K 근접 시 → 2K씩 두 청크로 분할
  - 2K 미만 시 → 두 청크 병합

#### 6.2 표준 라이브러리 구현
* **std::deque**: 청크 기반 구현
* **std::colony**: 건너뛰기 목록 사용 (대조적 접근)

#### 6.3 기타 최적화 기법
* **스킵 리스트**: 정렬된 연결 리스트 조회 속도 향상
* **한계**: 여전히 벡터 대비 캐시 미스 불리

---

> ### 📄 7장. 결론 및 실무 가이드라인

#### 7.1 핵심 원칙
1. **측정 우선**: 병목 지점 측정 후 최적화
2. **문제 해결 우선**: 성능 최적화보다 올바른 해결책 우선
3. **상황별 선택**: 사용 패턴에 따른 적절한 자료구조 선택

#### 7.2 선택 가이드라인
* **순차 접근 중심**: 배열/벡터 선택
* **빈번한 삽입/삭제 + 참조 보존**: 연결 리스트 고려
* **대용량 + 유연성**: 하이브리드 접근법 검토
* **성능 크리티컬**: 실제 측정을 통한 검증 필수
